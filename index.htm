<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="stylesheet" href="style.css" type="text/css">

  <title>The Solar System</title>
  <script type="text/javascript" src="../libs/three.js"></script>
  <script type="text/javascript" src="../libs/stats.js"></script>
  <script type="text/javascript" src="../libs/OrbitControls.js"></script>
  <script type="text/javascript" src="../libs/dat.gui.js"></script>
  <script type="text/javascript" src="../libs/WebGL.js"></script>
  <script type="text/javascript" src="../libs/Lensflare.js"></script>


</head>
<body>
  <canvas id="main"></canvas>
  <div id="tips">Use W/A/S/D or your mouse to move. Try to click!</div>
  <div id="thumbnail">
    <img src="textures/thumbnail/sun.jpg" id="clickSun" width="75" height="75" vspace="0" onclick="clicksun()" alt="Sun"/><br>
    <img src="textures/thumbnail/mercury.jpg" id="clickMercury" width="75" height="75" vspace="0" onclick="clickMercury()" alt="Mercury"/><br>
    <img src="textures/thumbnail/venus.jpg" id="clickVenus" width="75" height="75" vspace="0" onclick="clickVenus()" alt="Venus"/><br>
    <img src="textures/thumbnail/earth.jpg" id="clickEarth" width="75" height="75" vspace="0" onclick="clickEarth()" alt="Earth"/><br>
    <img src="textures/thumbnail/mars.jpg" id="clickMars" width="75" height="75" vspace="0" onclick="clickMars()" alt="Mars"/><br>
    <img src="textures/thumbnail/jupiter.jpg" id="clickJupiter" width="75" height="75" vspace="0" onclick="clickJupiter()" alt="Jupiter"/><br>
    <img src="textures/thumbnail/saturn.jpg" id="clickSaturn" width="75" height="75" vspace="0" onclick="clickSaturn()" alt="Saturn"/><br>
    <img src="textures/thumbnail/neptune.png" id="clickNeptune" width="75" height="75" vspace="0" onclick="clickNeptune()" alt="Neptune"/><br>
    <img src="textures/thumbnail/uranus.png" id="clickUranus" width="75" height="75" vspace="0" onclick="clickUranus()" alt="Uranus"/><br>
  </div>
  <div id="sunInfo">
    <p>
    <img src="textures/info/sun.png" width="500" height="350" align="right"/>
    &nbsp;&nbsp;太阳是太阳系的中心天体，占有太阳系总体质量的99.86%。太阳系中的八大行星、小行星、流星、彗星、外海王星天体以及星际尘埃等，都围绕着太阳公转，而太阳则围绕着银河系的中心公转。</p>
    &nbsp;&nbsp;太阳是位于太阳系中心的恒星，它几乎是热等离子体与磁场交织着的一个理想球体。太阳直径大约是1392000（1.392×10⁶）千米，相当于地球直径的109倍；体积大约是地球的130万倍；其质量大约是2×10³⁰千克（地球的330000倍）。从化学组成来看，现在太阳质量的大约四分之三是氢，剩下的几乎都是氦，包括氧、碳、氖、铁和其他的重元素质量少于2%，采用核聚变的方式向太空释放光和热。</p>
    &nbsp;&nbsp;太阳目前正在穿越银河系内部边缘猎户臂的本地泡区中的本星际云。在距离地球17光年的距离内有50颗最邻近的恒星系（与太阳距离最近的恒星是称作比邻星的红矮星，大约4.2光年）。</p>
    &nbsp;&nbsp;太阳是一颗黄矮星（光谱为G2V），黄矮星的寿命大致为100亿年，目前太阳大约45.7亿岁。 在大约50至60亿年之后，太阳内部的氢元素几乎会全部消耗尽，太阳的核心将发生坍缩，导致温度上升，这一过程将一直持续到太阳开始把氦元素聚变成碳元素。虽然氦聚变产生的能量比氢聚变产生的能量少，但温度也更高，因此太阳的外层将膨胀，并且把一部分外层大气释放到太空中。当转向新元素的过程结束时，太阳的质量将稍微下降，外层将延伸到地球或者火星目前运行的轨道处（这时由于太阳质量的下降，这两颗行星将会离太阳更远）。</p>
    <img src="textures/close.jpg"  id="close" alt="Close" width="30" height="30" align="right" onclick="clicksun()" />
  </div>
  <div id="mercuryInfo">
    
  </div>
  <div id="venusInfo">

  </div>
  <div id="earthInfo">

  </div>
  <div id="marsInfo">

  </div>
  <div id="jupiterInfo">

  </div>
  <div id="saturnInfo">

  </div>
  <div id="neptuneInfo">

  </div>
  <div id="uranusInfo">

  </div>


<script type="text/javascript">

  if (WEBGL.isWebGLAvailable() === false) {
    document.body.appendChild(WEBGL.getWebGLErrorMessage());
  }

  function clicksun(){
    var visibility = document.getElementById("sunInfo").style.visibility;
    if (visibility == "hidden") {
      document.getElementById("sunInfo").style.visibility = "visible";
      document.getElementById("thumbnail").style.visibility = "hidden";
    } else {
      document.getElementById("sunInfo").style.visibility = "hidden";
      document.getElementById("thumbnail").style.visibility = "visible";
    }
  }

  var scene, stats, axes, controls, camera, renderer;
  var canvas = document.getElementById("main");
  var particles,particlesSystem, buffer, positions, colors, color, sizes, gap;
  var Sun, Earth, Mars, Mercury, Moon, Jupiter, Saturn, Neptune, Uranus, Venus, stars = [];
  var starNames = {};
  var displayName;
  var mouse = new THREE.Vector2();
  var raycaster = new THREE.Raycaster();
  var srmesh1, srmesh2;

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    //scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

    //-----Stats-----//
    stats = new Stats();
    //stats.setMode(0);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    document.body.appendChild(stats.domElement);

    axes = new THREE.AxesHelper(5000);
    //scene.add(axes);

    camera = new THREE.PerspectiveCamera(60,window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.set(500, 500, 0);

    //-----plane-to-cube-----//
    var backPlane = createBack('back.png');
    backPlane.rotation.y = Math.PI / 2;
    backPlane.position.set(-2500, 0, 0);
    scene.add(backPlane);

    var frontPlane = createBack('front.png');
    frontPlane.rotation.y = -Math.PI / 2;
    frontPlane.position.set(2500, 0, 0);
    scene.add(frontPlane);

    var leftPlane = createBack('left.png');
    leftPlane.rotation.z = Math.PI;
    leftPlane.position.set(0, 0, 2500);
    scene.add(leftPlane);

    var rightPlane = createBack('right.png');
    //rightPlane.rotation.z = -Math.PI / 2;
    rightPlane.position.set(0, 0, -2500);
    scene.add(rightPlane);

    var topPlane = createBack('top.png');
    topPlane.rotation.x = Math.PI / 2;
    topPlane.position.set(0, 2500, 0);
    scene.add(topPlane);

    var bottomPlane = createBack('bottom.png');
    bottomPlane.rotation.x = Math.PI / 2;
    bottomPlane.position.set(0, -2500, 0);
    scene.add(bottomPlane);

    //-----Renderer-----//
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.shadowMapSoft = true;
    renderer.setPixelRatio(window.devicePixelRatio );
    renderer.setSize(window.innerWidth, window.innerHeight );
    document.body.appendChild(renderer.domElement );

    //-----Controls-----//
    controls = new THREE.OrbitControls(camera, renderer.domElement );
    controls.autoRotate = false;
    controls.autoRotateSpeed = 1;
    controls.enableKeys = true;
    controls.rotateSpeed = 0.5;
    controls.enableZoom = true;
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;
    controls.minDistance = 100;
    controls.maxDistance = 1200;
    controls.maxPolorAngle = Math.PI / 2;

    controls.keys = {
      A: 65,
      LEFT: 37,
      W: 87,
      UP: 38,
      D: 68,
      RIGHT: 39,
      S: 83,
      BOTTOM: 40,
      SPACE: 32
    };

    //-----cameraMove-----//
    function cameraMove() {
      camera.position.set(500, 500, 500);
    }

    //-----Geometry-----//
    Sun = createPlanet('Sun', 0, 0, 150, 0, 0.01, "sun.jpg");


    Mercury = createPlanet('Mercury', 240, 0, 12.2, 0.02, 1/30, 'mercury.jpg');
    stars.push(Mercury);
    Venus = createPlanet('Venus', 320, 0, 30.4, 0.012, 1/30, 'venus.jpg');
    stars.push(Venus);
    Earth = createPlanet('Earth', 400, 0, 31.9, 0.010, 1/30, 'earth.jpg');
    stars.push(Earth);
    Moon = createPlanet('Moon', 450, 0, 8.7, 0.010, 1/30, 'moon.jpg');
    stars.push(Moon);
    Mars = createPlanet('Mars', 500, 0, 17.0, 0.008, 1/30, 'mars.jpg');
    stars.push(Mars);
    Jupiter = createPlanet('Jupiter', 600, 0, 65.4, 0.006, 1/30, 'jupiter.jpg');
    stars.push(Jupiter);
    Saturn = createPlanet('Saturn', 750, 0, 44.7, 0.005, 1/30, 'saturn.png');
    stars.push(Saturn);
    Neptune = createPlanet('Neptune', 950, 0, 32.4, 0.003, 1/30, 'neptune.jpg');
    stars.push(Neptune);
    Uranus = createPlanet('Uranus', 1150, 0, 31.0, 0.002, 1/30, 'uranus.jpg');
    stars.push(Uranus);

    //-----Ring-----//
    var distance = [240, 320, 400, 500, 600, 750, 950, 1150];
    for (var i = 0; i < 8; i++) {
      var geometry = new THREE.RingGeometry(distance[i], distance[i] + 2, 90);
      var material = new THREE.MeshBasicMaterial({color: 0xddddaa, side: THREE.DoubleSide});
      var mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = - Math.PI / 2;
      scene.add(mesh);
    }
    //-----Saturn Ring-----//
    var srgeometry1 = new THREE.RingGeometry(63, 95, 60);
    var srmaterial1 = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
    var loader = new THREE.TextureLoader();
    var texture = loader.load("textures/saturnRing.png");
    srmaterial1.map = texture;
    srmesh1 = new THREE.Mesh(srgeometry1, srmaterial1);
    srmesh1.rotation.x = - Math.PI / 3;
    srmesh1.rotation.y = - Math.PI / 4;
    srmesh1.position.set(750, 0, 0);
    scene.add(srmesh1);

    var srgeometry2 = new THREE.RingGeometry(93, 95, 60);
    var srmaterial2 = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
    var texture2 = loader.load("texture/saturnRings.png");
    srmaterial2.map = texture2;
    srmesh2 = new THREE.Mesh(srgeometry2, srmaterial2);
    srmesh2.rotation.x = - Math.PI / 3;
    srmesh2.rotation.y = - Math.PI / 4;
    srmesh2.position.set(750, 0, 0);
    scene.add(srmesh2);

    //-----Lights-----//
    var sunlight1 = new THREE.DirectionalLight(0x999999, 0.8);
    sunlight1.position.set(1, 0, 0);
    // sunlight1.castShadow = true;
    scene.add(sunlight1);

    var sunlight2 = new THREE.DirectionalLight(0x999999, 0.8);
    sunlight2.position.set(-1, 0, 0);
    //sunlight2.castShadow = true;
    scene.add(sunlight2);

    var sunlight = new THREE.PointLight(0xddddaa, 5, 4000);
    sunlight.castShadow = true;
    scene.add(sunlight);

    //var sunlight2 = new THREE.pointColor

    var ambientLight = new THREE.AmbientLight(0xaaaaaa);
    scene.add(ambientLight);


    //-----background-stars-----//
    particles = 20000;
    buffer = new THREE.BufferGeometry();
    positions = new Float32Array(particles * 3);
    colors = new Float32Array(particles * 3);
    color = new THREE.Color();
    sizes = [];

    gap = 1500;

    for (var i = 0; i < positions.length; i += 3) {
      var x = (Math.random() * gap * 2) * (Math.random() < .5 ? -1 : 1);
      var y = (Math.random() * gap * 2) * (Math.random() < .5 ? -1 : 1);
      var z = (Math.random() * gap * 2) * (Math.random() < .5 ? -1 : 1);

      var max = Math.abs(x) > Math.abs(y) ? Math.abs(x) > Math.abs(z) ? 'x' : 'z': Math.abs(y) > Math.abs(z) ? 'y' : 'z';
      var pos = {x, y, z};

      if (Math.abs(pos[max]) < gap) {
        pos[max] = pos[max] < 0 ? -gap : gap;
      }

      x = pos['x'];
      y = pos['y'];
      z = pos['z'];

      positions[i]     = x;
      positions[i + 1] = y;
      positions[i + 2] = z;

      var hasColor = Math.random() > 0.3;
      var vx, vy, vz;

      if (hasColor) {
        vx = (Math.random() + 1) / 2;
        vy = (Math.random() + 1) / 2;
        vz = (Math.random() + 1) / 2;
      } else {
        vx = 1;
        vy = 1;
        vz = 1;
      }

      color.setRGB(vx, vy, vz);

      colors[i]     = color.r;
      colors[i + 1] = color.g;
      colors[i + 2] = color.b;
      sizes.push(20);
    }

    buffer.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    buffer.addAttribute('color', new THREE.BufferAttribute(colors, 3));
    buffer.addAttribute('size', new THREE.Float32BufferAttribute(sizes, 1).setDynamic(true));
    buffer.computeBoundingSphere();

    var material = new THREE.PointsMaterial({size: 6, vertexColors: THREE.VertexColors});
    particlesSystem = new THREE.Points(buffer, material);
    scene.add(particlesSystem);

    raycaster = new THREE.Raycaster(camera.position);
    raycaster.far = 1200;

    //onMouseDown
    window.addEventListener('mousedown', onMouseDown, false);
    //resize
    window.addEventListener('resize', onWindowResize, false);
    //onKeyDown
    window.addEventListener('keydown', onKeyDown, false);
  }

  //-----CustomMesh-----//
  function createPlanet(name, distance, angle, radius, revolutionSpeed, rotationSpeed, imageFile) {
    var loader = new THREE.TextureLoader();
    var texture = loader.load("textures/" + imageFile);
    var material = new THREE.MeshPhongMaterial({side: THREE.DoubleSide});
    //var material = new THREE.MeshPhongMaterial();
    material.map = texture;
    var geometry = new THREE.SphereGeometry(radius, 32, 32);
    var mesh = new THREE.Mesh(geometry, material);
    mesh.position.x = distance;
    mesh.receiveShadow = true;
    mesh.castShadow = true;
    mesh.name = name;

    var star = {
      name,
      distance,
      angle,
      radius,
      revolutionSpeed,
      rotationSpeed,
      Mesh : mesh
    };

    scene.add(mesh);

    return star;
  }

  function createBack(imageFile) {
    var loader = new THREE.TextureLoader();
    var texture = loader.load("textures/" + imageFile);
    var material = new THREE.MeshPhongMaterial({side: THREE.DoubleSide});
    material.map = texture;
    var geometry = new THREE.PlaneGeometry(5000, 5000);
    var mesh = new THREE.Mesh(geometry, material);
    mesh.material.transparent = true;
    mesh.material.opacity = 0.2;

    return mesh;
  }

  function createRing(geometry, imageFile) {
    var loader = new THREE.TextureLoader();
    var texture = loader.load("texture/" + imageFile);
    var material = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
    material.map = texture;

    var mesh = new THREE.Mesh(geometry, material);
    return mesh;
  }

  //-----displayName-----//
  function displayName() {
    stars.forEach(nameConstructor(star.name));
    nameConstructor('Sun');

    function nameConstructor(name) {
      var planetName = new Three.Mesh(
        new THREE.TextGeometry(name, {size: 4, height: 4}),
        new THREE.MeshBasicMaterial({color: 0xffffff, side: THREE.DoubleSide}));
      planetName.visible = false;
      starNames[name] = planetName;
      scene.add(planetName);
    }
  }

  //-----Orbital revolution-----//
  //比例：1：2.5：4.1：7.8：49.2：123.1：350.0：385.5
  function revolution() {
    for (var i = 0; i < stars.length; i++) {
      stars[i].angle += stars[i].revolutionSpeed;
      stars[i].Mesh.position.set(stars[i].distance * Math.sin(stars[i].angle), 0,
                              stars[i].distance * Math.cos(stars[i].angle));
    }

    srmesh1.position.copy(stars[6].Mesh.position);
    srmesh2.position.copy(stars[6].Mesh.position);

  }

  //-----Rotation-----//
  //25.1:58.6:243.0:1.0:1.0:0.4:0.4:0.7:0.7
  function rotation() {
    for (var i = 0; i < stars.length; i++) {
      stars[i].Mesh.rotation.y += stars[i].rotationSpeed;
    }
    Sun.Mesh.rotation.y += Sun.rotationSpeed;
  }

  //-----GUI-----//
  var gui = new dat.GUI();

  //
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  //
  function onMouseDown(event) {
    event.preventDefault();
    if (event.button == 0) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera( mouse, camera );
      var intersects = raycaster.intersectObjects(scene.children);
      if (intersects.length > 0) {
        for (var i = 0; i < intersects.length; i++) {
          if (intersects[i].distance <= 3000) {
            console.log(intersects[0]);
            //intersects[0].object.material.color.set(0xff0000);
          }
        }
      }
    }

  }

  //
  function onKeyDown(event) {
    var keyCode = event.keyCode;
    switch (keyCode) {
      case 65:
      case 37:
        camera.position.x += 10;
        console.log('push a');
        break;
      case 87:
      case 38:
       console.log('push w');
        break;
      case 68:
      case 39:
        console.log('push d');
        break;
      case 83:
      case 40:
        console.log('push s');
        break;
      case 32:
        camera.position.set(500, 500, 0);
        break;
      default:

    }
  }

  //
  function animate() {
    revolution();
    rotation();
    requestAnimationFrame( animate );
    controls.update();
    stats.update();
    render();
  }

  function render() {
    camera.lookAt(0,0,0);
    camera.updateMatrixWorld();
    var time = Date.now() * 0.005;
    particlesSystem.rotation.y = 0.01 * time;
    var sizes = buffer.attributes.size.array;
    for (var i = 0; i < particles; i++) {
      sizes[i] = 10 * (1 + Math.sin(0.1 * i + time));
    }
    buffer.attributes.size.needsUpdate = true;

    renderer.render(scene, camera);
  }

  init();
  animate();

</script>

</body>
</html>
