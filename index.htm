<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
  <title>The Solar System</title>
  <script type="text/javascript" src="../libs/three.js"></script>
  <script type="text/javascript" src="../libs/stats.js"></script>
  <script type="text/javascript" src="../libs/OrbitControls.js"></script>
  <script type="text/javascript" src="../libs/dat.gui.js"></script>
  <script type="text/javascript" src="../libs/WebGL.js"></script>
  <script type="text/javascript" src="../libs/Lensflare.js"></script>

</head>
<body>
  <div id="WebGL-output">
  </div>

  <!-- <script type="x-shader/x-vertex" id="vertexShader">
    varying vec3 vVertexWorldPosition;
    varying vec3 vVertexNormal;
    varying vec4 vFragColor;

    void main() {
      vVertexNormal = normalize(normalMatrix * normal);
      vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  </script>

  <script type="x-shader/x-fragment" id="fragmentShader">
    uniform vec3 glowColor;
    uniform float coeficient;
    uniform float power;

    varying vec3 vVertexNormal;
    varying vec3 vVertexWorldPosition;
    varying vec4 vFragColor;

    void main() {
      vec3 worldVertexToCamera = cameraPosition - vVertexWorldPosition;
      vec3 viewCameraToVertex = (viewMatrix * vec4(worldVertexToCamera, 0.0)).xyz;
      viewCameraToVertex = normalize(viewCameraToVertex);
      float intensity = coeficient + dot(vVertexNormal, viewCameraToVertex);
      if(intensity > 0.65) {
        intensity = 0.0;
      }
      gl_FragColor = vec4(glowColor, intensity);
    }
  </script> -->

<script type="text/javascript">

  if (WEBGL.isWebGLAvailable() === false) {
    document.body.appendChild(WEBGL.getWebGLErrorMessage());
  }

  init();
  animate();

  var scene, stats, axes, controls, camera, canvas, renderer;
  var particles,particlesSystem, buffer, positions, colors, color, sizes, gap;
  var sun, earth, mars, mercury, moon, jupiter, saturn, neptune, uranus, venus;

  function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    //scene.fog = new THREE.FogExp2(0xcccccc, 0.002);

    //-----Stats-----//
    stats = new Stats();
    //stats.setMode(0);
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.left = '0px';
    stats.domElement.style.top = '0px';
    document.body.appendChild(stats.domElement);

    axes = new THREE.AxesHelper(5000);
    //scene.add(axes);

    camera = new THREE.PerspectiveCamera(60,window.innerWidth / window.innerHeight, 1, 10000);
    camera.position.set(500, 500, 0);

    //-----plane-to-cube-----//
    var backPlane = createMesh(new THREE.PlaneBufferGeometry(5000, 5000), "back.png");
    backPlane.rotation.y = Math.PI / 2;
    backPlane.position.set(-2500, 0, 0);
    scene.add(backPlane);

    var frontPlane = createMesh(new THREE.PlaneBufferGeometry(5000, 5000), "front.png");
    frontPlane.rotation.y = -Math.PI / 2;
    frontPlane.position.set(2500, 0, 0);
    scene.add(frontPlane);

    var leftPlane = createMesh(new THREE.PlaneBufferGeometry(5000, 5000), "left.png");
    leftPlane.rotation.z = Math.PI;
    leftPlane.position.set(0, 0, 2500);
    scene.add(leftPlane);

    var rightPlane = createMesh(new THREE.PlaneBufferGeometry(5000, 5000), "right.png");
    //rightPlane.rotation.z = -Math.PI / 2;
    rightPlane.position.set(0, 0, -2500);
    scene.add(rightPlane);

    var topPlane = createMesh(new THREE.PlaneBufferGeometry(5000, 5000), "top.png");
    topPlane.rotation.x = Math.PI / 2;
    topPlane.position.set(0, 2500, 0);
    scene.add(topPlane);

    var bottomPlane = createMesh(new THREE.PlaneBufferGeometry(5000, 5000), "bottom.png");
    bottomPlane.rotation.x = Math.PI / 2;
    bottomPlane.position.set(0, -2500, 0);
    scene.add(bottomPlane);

    //-----Renderer-----//
    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.shadowMap.enabled = true;
    renderer.shadowMapSoft = true;
    renderer.setPixelRatio(window.devicePixelRatio );
    renderer.setSize(window.innerWidth, window.innerHeight );
    document.getElementById('WebGL-output').appendChild(renderer.domElement );

    //-----Controls-----//
    controls = new THREE.OrbitControls(camera, renderer.domElement );
    controls.rotateSpeed = 0.5;
    controls.panSpeed = 0.5;
    controls.ketPanSpeed = 3.5;
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;
    controls.minDistance = 100;
    controls.maxDistance = 1200;
    controls.maxPolorAngle = Math.PI / 2;

    controls.keys = {
      A: 65,
      LEFT: 37,
      W: 87,
      UP: 38,
      D: 68,
      RIGHT: 39,
      S: 83,
      BOTTOM: 40,
      SPACE: 32
    };

    //-----cameraMove-----//
    function cameraMove() {
      camera.position.set(500, 500, 500);
    }

    //-----Geometry-----//
    sun = createMesh(new THREE.SphereGeometry(150, 32, 32), "sun.jpg");

    //-----sun sprites-----//
    // var spriteMap = new THREE.TextureLoader().load("textures/sprite.png");
    // var spriteMaterial = new THREE.SpriteMaterial({map: spriteMap, color:0xff0000});
    // var sprite = new THREE.Sprite(spriteMaterial);
    // sprite.scale.set(2, 2, 1);
    // sprite.position.set(200, 100, 100);
    // scene.add(sprite);

    //-----glow-----//
    // var geometry_glow = new THREE.SphereBufferGeometry(155, 32, 32);
    // var material_glow = new THREE.ShaderMaterial({
    //   uniforms: {
    //     coeficient: {
    //       type: "f",
    //       value: 0.0
    //     },
    //     power: {
    //       type: "f",
    //       value: 0.0
    //     },
    //     glowColor: {
    //       type: "c",
    //       value: new THREE.Color('red')
    //     }
    //   },
    //   vertexShader: document.getElementById('vertexShader').textContent,
    //   fragmentShader: document.getElementById('fragmentShader').textContent
    // });
    // var glow = new THREE.Mesh(geometry_glow, material_glow);
    // scene.add(glow);

    mercury = createMesh(new THREE.SphereGeometry(12.2, 32, 32), "mercury.jpg");
    mercury.position.set(240, 0, 0);
    mercury.receiveShadow = true;

    venus = createMesh(new THREE.SphereGeometry(30.4, 32, 32), "venus.jpg");
    venus.position.set(320, 0, 0);
    venus.receiveShadow = true;

    earth = createMesh(new THREE.SphereGeometry(31.9, 32, 32), "earth.jpg");
    earth.position.set(400, 0, 0);
    //earth.receiveShadow = true;
    earth.castShadow = true;

    moon = createMesh(new THREE.SphereGeometry(8.7, 32, 32), "moon.jpg");
    moon.position.set(450, 0, 0);
    moon.parent = earth;
    moon.receiveShadow = true;

    mars = createMesh(new THREE.SphereGeometry(17.0, 32, 32), "mars.jpg");
    mars.position.set(500, 0, 0);
    mars.receiveShadow = true;

    jupiter = createMesh(new THREE.SphereGeometry(65.4, 32, 32), "jupiter.jpg");
    jupiter.position.set(600, 0, 0);
    jupiter.receiveShadow = true;

    saturn = createMesh(new THREE.SphereGeometry(44.7, 32, 32), "saturn.png");
    saturn.position.set(750, 0, 0);
    saturn.receiveShadow = true;

    neptune = createMesh(new THREE.SphereGeometry(32.4, 32, 32), "neptune.jpg");
    neptune.position.set(950, 0, 0);
    neptune.receiveShadow = true;

    uranus = createMesh(new THREE.SphereGeometry(31.0, 32, 32), "uranus.jpg");
    uranus.position.set(1150, 0, 0);
    uranus.receiveShadow = true;

    scene.add(sun);
    scene.add(mercury);
    scene.add(venus);
    scene.add(earth);
    scene.add(moon);
    scene.add(mars);
    scene.add(jupiter);
    scene.add(saturn);
    scene.add(neptune);
    scene.add(uranus);

    //-----Ring-----//
    var distance = [240, 320, 400, 500, 600, 750, 950, 1150];
    for (var i = 0; i < 8; i++) {
      var geometry = new THREE.RingGeometry(distance[i], distance[i] + 2, 90);
      var material = new THREE.MeshBasicMaterial({color: 0xddddaa, side: THREE.DoubleSide});
      var mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = - Math.PI / 2;
      scene.add(mesh);
    }
    //-----Saturn Ring-----//
    var srgeometry1 = new THREE.RingGeometry(63, 95, 60);
    var srmaterial1 = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
    var loader = new THREE.TextureLoader();
    var texture = loader.load("textures/saturnRing.png");
    srmaterial1.map = texture;
    var srmesh1 = new THREE.Mesh(srgeometry1, srmaterial1);
    srmesh1.rotation.x = - Math.PI / 3;
    srmesh1.rotation.y = - Math.PI / 4;
    srmesh1.position.set(750, 0, 0);
    scene.add(srmesh1);

    var srgeometry2 = new THREE.RingGeometry(93, 95, 60);
    var srmaterial2 = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
    var texture2 = loader.load("texture/saturnRings.png");
    srmaterial2.map = texture2;
    var srmesh2 = new THREE.Mesh(srgeometry2, srmaterial2);
    srmesh2.rotation.x = - Math.PI / 3;
    srmesh2.rotation.y = - Math.PI / 4;
    srmesh2.position.set(750, 0, 0);
    scene.add(srmesh2);

    //-----Lights-----//
    var sunlight1 = new THREE.DirectionalLight(0xddddaa);
    sunlight1.position.set(1, 1, 1);
    // sunlight1.castShadow = true;
    scene.add(sunlight1);

    // var sunlight2 = new THREE.DirectionalLight(0xffffff);
    // sunlight2.position.set(-1, -1, -1);
    // sunlight2.castShadow = true;
    // scene.add(sunlight2);

    var sunlight = new THREE.PointLight(0xddddaa, 2.5, 0);
    sunlight.castShadow = true;
    scene.add(sunlight);

    //var sunlight2 = new THREE.pointColor

    var ambientLight = new THREE.AmbientLight(0xaaaaaa);
    scene.add(ambientLight);


    //-----background-stars-----//
    particles = 20000;
    buffer = new THREE.BufferGeometry();
    positions = new Float32Array(particles * 3);
    colors = new Float32Array(particles * 3);
    color = new THREE.Color();
    sizes = [];

    gap = 1500;

    for (var i = 0; i < positions.length; i += 3) {
      var x = (Math.random() * gap * 2) * (Math.random() < .5 ? -1 : 1);
      var y = (Math.random() * gap * 2) * (Math.random() < .5 ? -1 : 1);
      var z = (Math.random() * gap * 2) * (Math.random() < .5 ? -1 : 1);

      var max = Math.abs(x) > Math.abs(y) ? Math.abs(x) > Math.abs(z) ? 'x' : 'z': Math.abs(y) > Math.abs(z) ? 'y' : 'z';
      var pos = {x, y, z};

      if (Math.abs(pos[max]) < gap) {
        pos[max] = pos[max] < 0 ? -gap : gap;
      }

      x = pos['x'];
      y = pos['y'];
      z = pos['z'];

      positions[i]     = x;
      positions[i + 1] = y;
      positions[i + 2] = z;

      var hasColor = Math.random() > 0.3;
      var vx, vy, vz;

      if (hasColor) {
        vx = (Math.random() + 1) / 2;
        vy = (Math.random() + 1) / 2;
        vz = (Math.random() + 1) / 2;
      } else {
        vx = 1;
        vy = 1;
        vz = 1;
      }

      color.setRGB(vx, vy, vz);

      colors[i]     = color.r;
      colors[i + 1] = color.g;
      colors[i + 2] = color.b;
      sizes.push(20);
    }

    buffer.addAttribute('position', new THREE.BufferAttribute(positions, 3));
    buffer.addAttribute('color', new THREE.BufferAttribute(colors, 3));
    buffer.addAttribute('size', new THREE.Float32BufferAttribute(sizes, 1).setDynamic(true));
    buffer.computeBoundingSphere();

    // uniforms = {
    //   texture: {value: new THREE.TextureLoader().load('textures/sprites/spark1.png')}
    // };
    //
    // var shaderMaterial = new THREE.ShaderMaterial({
    //   uniforms: uniforms,
    //   //vertexShader: document.getElementById('vertexshader').textContent,
    //   //fragmentShader: document.getElementById('fragmentshader').textContent,
    //
    //   blending: THREE.AdditiveBlending,
    //   depthTest: false,
    //   transparent: true,
    //   vertexColors: true
    // });
    var material = new THREE.PointsMaterial({size: 6, vertexColors: THREE.VertexColors});
    particlesSystem = new THREE.Points(buffer, material);
    scene.add(particlesSystem);

    //resize
    window.addEventListener('resize', onWindowResize, false);
  }

  //-----GUI-----//
  var gui = new dat.GUI();

  //-----CustomMesh-----//
  function createMesh(geometry, imageFile) {
    var loader = new THREE.TextureLoader();
    var texture = loader.load("textures/" + imageFile);
    var material = new THREE.MeshPhongMaterial({side: THREE.DoubleSide});
    //var material = new THREE.MeshPhongMaterial();
    material.map = texture;

    var mesh = new THREE.Mesh(geometry, material);
    return mesh;
  }

  function createRing(geometry, imageFile) {
    var loader = new THREE.TextureLoader();
    var texture = loader.load("texture/" + imageFile);
    var material = new THREE.MeshBasicMaterial({side: THREE.DoubleSide});
    material.map = texture;

    var mesh = new THREE.Mesh(geometry, material);
    return mesh;
  }

  //-----Orbital revolution-----//
  function revolution() {
    sun.rotation.y += 0.01;
    earth.rotation.y += 0.01;
    mars.rotation.y += 0.01;
    mercury.rotation.y += 0.01;
    moon.rotation.y += 0.01;
    neptune.rotation.y += 0.01;
    uranus.rotation.y += 0.01;
    venus.rotation.y += 0.01;
    jupiter.rotation.y += 0.01;
    saturn.rotation.y += 0.01;
  }

  //-----Rotation-----//




  //
  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  //
  function animate() {
    requestAnimationFrame( animate );
    controls.update();
    stats.update();
    render();
  }

  function render() {

    revolution();

    var time = Date.now() * 0.005;
    particlesSystem.rotation.y = 0.01 * time;
    var sizes = buffer.attributes.size.array;
    for (var i = 0; i < particles; i++) {
      sizes[i] = 10 * (1 + Math.sin(0.1 * i + time));
    }
    buffer.attributes.size.needsUpdate = true;

    renderer.render(scene, camera);
  }
</script>

</body>
</html>
